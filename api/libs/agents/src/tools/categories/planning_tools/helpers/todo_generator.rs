use anyhow::Result;
use litellm::{AgentMessage, ChatCompletionRequest, LiteLLMClient, Metadata, ResponseFormat};
use serde_json::Value;
use tracing::{error, warn};
use uuid::Uuid;

/// Generates a list of todo items (as JSON Values for agent state) from a plan string using an LLM.
///
/// # Arguments
///
/// * `plan` - The plan string generated by the primary LLM.
/// * `user_id` - The ID of the user.
/// * `session_id` - The ID of the current session.
///
/// # Returns
///
/// A `Result` containing a `Vec<Value>` where each `Value` is a JSON object representing a todo item
/// (`{"completed": false, "todo": "..."}`), or an error if generation or parsing fails.
pub async fn generate_todos_from_plan(
    plan: &str,
    user_id: Uuid,
    session_id: Uuid,
) -> Result<Vec<Value>> {
    let llm_client = LiteLLMClient::new(None, None);

    let prompt = format!(
        r#"
Given the following plan, extract the actionable steps and return them as a JSON list of descriptive todo strings. Each todo item should clearly describe the task to be performed, providing enough detail to understand its purpose within the overall plan. Avoid overly simple descriptions. 

**IMPORTANT**: Do not include any steps related to reviewing, verifying, summarizing, or responding to the user. Only include the core creation or modification tasks.

Plan:
"""
{}
"""

Return ONLY a valid JSON array of strings, where each string is a descriptive todo item corresponding to a main creation/modification step in the plan.
Example format: `["Create a number card visualization titled 'Top Customer by Lifetime Revenue' using specified datasets"]`
"#,
        plan
    );

    let request = ChatCompletionRequest {
        model: "gemini-2.0-flash-001".to_string(),
        messages: vec![AgentMessage::User { id: None, content: prompt, name: None }],
        stream: Some(false),
        response_format: Some(ResponseFormat { type_: "json_object".to_string(), json_schema: None }),
        metadata: Some(Metadata {
            generation_name: "generate_todos_from_plan".to_string(),
            user_id: user_id.to_string(),
            session_id: session_id.to_string(),
            trace_id: Uuid::new_v4().to_string(),
        }),
        max_completion_tokens: Some(1024),
        temperature: Some(0.0),
        ..Default::default()
    };

    let response = llm_client.chat_completion(request).await?;

    let content = match response.choices.get(0).and_then(|c| c.message.get_content()) {
        Some(content) => content,
        None => return Err(anyhow::anyhow!("LLM response for todo generation was empty or malformed")),
    };

    // Assuming the LLM returns a JSON object like `{"todos": ["...", "..."]}` or just the array `["", ""]`
    let parsed_value: Value = serde_json::from_str(&content).map_err(|e| {
        error!("Failed to parse LLM JSON response for todos: {}. Content: {}", e, content);
        anyhow::anyhow!("Failed to parse LLM JSON response for todos: {}", e)
    })?;

    let todo_strings: Vec<String> = match parsed_value {
        Value::Array(arr) => arr
            .into_iter()
            .filter_map(|v| v.as_str().map(String::from))
            .collect(),
        Value::Object(mut map) => map
            .remove("todos") // Attempt to extract from a common pattern like {"todos": [...]} 
            .and_then(|v| v.as_array().cloned())
            .map(|arr| {
                arr.into_iter()
                    .filter_map(|v| v.as_str().map(String::from))
                    .collect()
            })
            .unwrap_or_else(|| {
                warn!("LLM todo response was object but did not contain a 'todos' array or it was not an array of strings. Content: {}", content);
                vec![]
            }),
        _ => {
            warn!("Unexpected JSON structure for todos from LLM. Content: {}", content);
            return Err(anyhow::anyhow!("Unexpected JSON structure for todos from LLM"));
        }
    };

    let todos_state_objects: Vec<Value> = todo_strings
        .into_iter()
        .map(|item| {
            let mut map = serde_json::Map::new();
            map.insert("completed".to_string(), Value::Bool(false));
            map.insert("todo".to_string(), Value::String(item));
            Value::Object(map)
        })
        .collect();

    Ok(todos_state_objects)
} 