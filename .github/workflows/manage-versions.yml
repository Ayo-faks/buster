name: Manage Versions

on:
  workflow_dispatch:
    inputs:
      component:
        description: 'Component to version bump'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - api
          - web
          - cli
      version_spec:
        description: 'Version bump type (patch, minor, major) or specific version (e.g., 1.2.3)'
        required: true
        default: 'patch'
        type: string
  pull_request:
    branches:
      - evals # Target the 'evals' branch

permissions:
  contents: write # To push commits and tags

jobs:
  bump_versions:
    runs-on: blacksmith
    # Updated condition to run if PR is opened or on workflow_dispatch
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'pull_request'
    outputs:
      new_api_version: ${{ steps.bump.outputs.new_api_version }}
      new_web_version: ${{ steps.bump.outputs.new_web_version }}
      new_cli_version: ${{ steps.bump.outputs.new_cli_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }} # Or a PAT if you push to protected branches from actions
          fetch-depth: 0 # For git tagging and history

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20' # Specify a Node.js version

      - name: Set up Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Install cargo-edit
        run: cargo install cargo-edit --locked

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Determine Version Spec and Component from Event
        id: event_params
        shell: bash
        run: |
          VERSION_SPEC=""
          COMPONENT=""
          COMMIT_MESSAGE_TEXT=""

          echo "Event name: ${{ github.event_name }}"

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION_SPEC="${{ github.event.inputs.version_spec }}"
            COMPONENT="${{ github.event.inputs.component }}"
            echo "Using workflow_dispatch inputs: version_spec='$VERSION_SPEC', component='$COMPONENT'"
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            COMMIT_MESSAGE_TEXT=$(echo "${{ github.event.head_commit.message }}" | tr '[:upper:]' '[:lower:]')
            echo "Push event. Analyzing commit message (lowercase): $COMMIT_MESSAGE_TEXT"
            COMPONENT="all" # Default component for push events

            if echo "$COMMIT_MESSAGE_TEXT" | grep -q -E "breaking change|feat!:"; then
              VERSION_SPEC="major"
            elif echo "$COMMIT_MESSAGE_TEXT" | grep -q -E "^feat\\([^)]+\\)!:"; then # e.g., feat(scope)!:
              VERSION_SPEC="major"
            elif echo "$COMMIT_MESSAGE_TEXT" | grep -q -E "^feat:"; then
              VERSION_SPEC="minor"
            elif echo "$COMMIT_MESSAGE_TEXT" | grep -q -E "^fix:"; then
              VERSION_SPEC="patch"
            else
              echo "No major/minor/fix keyword found in commit message. Defaulting to patch."
              VERSION_SPEC="patch"
            fi
            echo "Determined for push: version_spec='$VERSION_SPEC', component='$COMPONENT'"
          else
            echo "Unhandled event type: ${{ github.event_name }}. Defaulting to patch and all."
            VERSION_SPEC="patch"
            COMPONENT="all"
          fi

          if [[ -z "$VERSION_SPEC" ]]; then
            echo "Warning: VERSION_SPEC is empty after evaluation. Defaulting to patch."
            VERSION_SPEC="patch"
          fi
          if [[ -z "$COMPONENT" ]]; then
            echo "Warning: COMPONENT is empty after evaluation. Defaulting to all."
            COMPONENT="all"
          fi

          echo "Final determined version_spec: $VERSION_SPEC"
          echo "Final determined component: $COMPONENT"

          echo "version_spec=$VERSION_SPEC" >> $GITHUB_OUTPUT
          echo "component=$COMPONENT" >> $GITHUB_OUTPUT

      - name: Perform Version Bumps
        id: bump
        shell: bash
        run: |
          COMPONENT="${{ steps.event_params.outputs.component }}"
          VERSION_SPEC="${{ steps.event_params.outputs.version_spec }}"

          echo "Component for bump: $COMPONENT"
          echo "Version spec for bump: $VERSION_SPEC"

          COMMIT_MESSAGE_PREFIX="chore(versions):"
          COMMIT_CHANGES=false

          NEW_API_VERSION=""
          NEW_WEB_VERSION=""
          NEW_CLI_VERSION=""

          # API Version Bump
          if [[ "$COMPONENT" == "all" || "$COMPONENT" == "api" ]]; then
            echo "Processing API version using spec: $VERSION_SPEC..."
            cd api/server
            OLD_API_VERSION=$(grep '^version *=' Cargo.toml | sed 's/version *= *"\\(.*\\)"/\\1/')
            if [[ "$VERSION_SPEC" == "major" || "$VERSION_SPEC" == "minor" || "$VERSION_SPEC" == "patch" ]]; then
              echo "Bumping API version with --bump $VERSION_SPEC"
              cargo set-version --bump "$VERSION_SPEC"
            else
              CLEANED_VERSION_SPEC=$(echo "$VERSION_SPEC" | sed 's/^v//')
              echo "Setting API version to $CLEANED_VERSION_SPEC"
              cargo set-version "$CLEANED_VERSION_SPEC"
            fi
            NEW_API_VERSION=$(grep '^version *=' Cargo.toml | sed 's/version *= *"\\(.*\\)"/\\1/')
            echo "API: $OLD_API_VERSION -> $NEW_API_VERSION"
            cd ../..
            if [[ "$OLD_API_VERSION" != "$NEW_API_VERSION" ]]; then
              git add api/server/Cargo.toml
              COMMIT_MESSAGE_PREFIX="$COMMIT_MESSAGE_PREFIX bump api to v$NEW_API_VERSION;"
              COMMIT_CHANGES=true
              echo "new_api_version=$NEW_API_VERSION" >> $GITHUB_OUTPUT
            fi
          fi

          # Web Version Bump
          if [[ "$COMPONENT" == "all" || "$COMPONENT" == "web" ]]; then
            echo "Bumping Web version using spec: $VERSION_SPEC..."
            cd web
            OLD_WEB_VERSION=$(jq -r .version package.json)
            # npm version can handle bump types and specific versions directly
            npm version "$VERSION_SPEC" --no-git-tag-version --allow-same-version
            NEW_WEB_VERSION=$(jq -r .version package.json)
            echo "Web: $OLD_WEB_VERSION -> $NEW_WEB_VERSION"
            cd ..
            if [[ "$OLD_WEB_VERSION" != "$NEW_WEB_VERSION" ]]; then
              git add web/package.json web/package-lock.json # package-lock.json might also change
              COMMIT_MESSAGE_PREFIX="$COMMIT_MESSAGE_PREFIX bump web to v$NEW_WEB_VERSION;"
              COMMIT_CHANGES=true
              echo "new_web_version=$NEW_WEB_VERSION" >> $GITHUB_OUTPUT
            fi
          fi

          # CLI Version Bump
          if [[ "$COMPONENT" == "all" || "$COMPONENT" == "cli" ]]; then
            echo "Processing CLI version using spec: $VERSION_SPEC..."
            cd cli/cli
            OLD_CLI_VERSION=$(grep '^version *=' Cargo.toml | sed 's/version *= *"\\(.*\\)"/\\1/')
            if [[ "$VERSION_SPEC" == "major" || "$VERSION_SPEC" == "minor" || "$VERSION_SPEC" == "patch" ]]; then
              echo "Bumping CLI version with --bump $VERSION_SPEC"
              cargo set-version --bump "$VERSION_SPEC"
            else
              CLEANED_VERSION_SPEC=$(echo "$VERSION_SPEC" | sed 's/^v//')
              echo "Setting CLI version to $CLEANED_VERSION_SPEC"
              cargo set-version "$CLEANED_VERSION_SPEC"
            fi
            NEW_CLI_VERSION=$(grep '^version *=' Cargo.toml | sed 's/version *= *"\\(.*\\)"/\\1/')
            echo "CLI: $OLD_CLI_VERSION -> $NEW_CLI_VERSION"
            cd ../..
            if [[ "$OLD_CLI_VERSION" != "$NEW_CLI_VERSION" ]]; then
              git add cli/cli/Cargo.toml
              COMMIT_MESSAGE_PREFIX="$COMMIT_MESSAGE_PREFIX bump cli to v$NEW_CLI_VERSION;"
              COMMIT_CHANGES=true
              echo "new_cli_version=$NEW_CLI_VERSION" >> $GITHUB_OUTPUT
            fi
          fi
          
          if [[ "$COMMIT_CHANGES" == true ]]; then
            # Remove trailing semicolon if any
            FINAL_COMMIT_MESSAGE=$(echo "$COMMIT_MESSAGE_PREFIX" | sed 's/;$//')
            echo "Final Commit Message: $FINAL_COMMIT_MESSAGE [skip ci]"
            echo "COMMIT_MESSAGE_CONTENT=$FINAL_COMMIT_MESSAGE [skip ci]" >> $GITHUB_ENV 
            echo "commit_message=$FINAL_COMMIT_MESSAGE [skip ci]" >> $GITHUB_OUTPUT
          else
            echo "No version changes detected."
            echo "COMMIT_MESSAGE_CONTENT=" >> $GITHUB_ENV # Ensure it's empty
            echo "commit_message=" >> $GITHUB_OUTPUT
          fi
          echo "New API Version Output: $NEW_API_VERSION"
          echo "New Web Version Output: $NEW_WEB_VERSION"
          echo "New CLI Version Output: $NEW_CLI_VERSION"

      - name: Commit version changes
        if: steps.bump.outputs.commit_message != ''
        env:
          COMMIT_MESSAGE_TO_USE: ${{ steps.bump.outputs.commit_message }}
        run: |
          git commit -m "$COMMIT_MESSAGE_TO_USE"

      - name: Create and Push Tags
        if: steps.bump.outputs.commit_message != '' # Only tag if there were changes
        run: |
          echo "Creating and pushing tags..."
          NEW_API_VERSION="${{ steps.bump.outputs.new_api_version }}"
          NEW_WEB_VERSION="${{ steps.bump.outputs.new_web_version }}"
          NEW_CLI_VERSION="${{ steps.bump.outputs.new_cli_version }}"

          if [[ -n "$NEW_API_VERSION" ]]; then
            echo "Tagging API: api/v$NEW_API_VERSION"
            git tag "api/v$NEW_API_VERSION"
          fi
          if [[ -n "$NEW_WEB_VERSION" ]]; then
            echo "Tagging Web: web/v$NEW_WEB_VERSION"
            git tag "web/v$NEW_WEB_VERSION"
          fi
          if [[ -n "$NEW_CLI_VERSION" ]]; then
            echo "Tagging CLI: cli/v$NEW_CLI_VERSION"
            git tag "cli/v$NEW_CLI_VERSION"
          fi
          
          git push origin HEAD --follow-tags # Push current branch and all tags

      - name: Push changes (if only commit, no tags yet or if tag push failed)
        # This condition implies commit happened, but no versions were actually outputted.
        # This might occur if a bump was attempted but the version didn't change.
        # The original condition was:
        # if: steps.bump.outputs.commit_message != '' && (steps.bump.outputs.new_api_version == '' && steps.bump.outputs.new_web_version == '' && steps.bump.outputs.new_cli_version == '')
        # A simpler way to check if tags were created might be needed or this step might be redundant if --follow-tags is robust.
        # For now, keeping the original logic.
        if: steps.bump.outputs.commit_message != '' && (steps.bump.outputs.new_api_version == '' && steps.bump.outputs.new_web_version == '' && steps.bump.outputs.new_cli_version == '')
        run: |
          echo "Pushing commit because changes were made but no version tags were generated (e.g. version already existed or no actual version change)."
          git push origin HEAD 